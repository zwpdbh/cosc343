#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch)
#pragma config(Sensor, S2,     rightBumper,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// GOLOBAL VARIABLES
int totalBlackTile = 0;
int MOVINGSPEED = 30;
float targetDistance = 255.0;

// variables for scan
bool RIGHT = true;
bool LEFT = false;
bool approachingTarget = false;
int TURNINGSPEED = 10;

// variables for test boundary
int MAX_BOUNDARY_EXPECTED = 4*100;
int rightBoundaryDegree = 0;
int leftBoundaryDegree = 0;
int differences = 30;


/**DEFINED FUNCTION */

/** in these turning function, the robot do two things: 
 * turning and recording the distance it get from the sensor.
 * For turning, it turns in its fixed postion with one wheel roll ahead and the other roll backward.
 * For scanning, it keep geting the distance in front ot it, it the distance should decrease first,
 * and increase as it turns away from the robot.
 * just as the distance is getting larger, it stop the turning.s 
 */
void turn(int degreeToTurn, int TURNINGSPEED){
    float previousDistance = getUSDistance(sonarSensor);
    float currentDistance = getUSDistance(sonarSensor);

    degreeToTurn = degreeToTurn * 2;
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    if (degreeToTurn >= 0) {
        setMotorTarget(leftMotor, degreeToTurn, TURNINGSPEED);
        setMotorTarget(rightMotor, -degreeToTurn, TURNINGSPEED);
        while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getTouchValue(leftBumper)!=1 && getTouchValue(rightBumper)!=1) {
            setMotorSync(leftMotor, rightMotor, 100, TURNINGSPEED);
            currentDistance = getUSDistance(sonarSensor);
            if (currentDistance<previousDistance) {
                previousDistance = currentDistance; // it means it is turning toward to target;
                approachingTarget = true;
            } else if (approachingTarget && currentDistance > previousDistance && previousDistance < targetDistance) {
                targetDistance = previousDistance;
                return;
            }
        }
    } else if (degreeToTurn <= 0) {
        degreeToTurn = -1 * degreeToTurn;
        setMotorTarget(leftMotor, -degreeToTurn, TURNINGSPEED);
        setMotorTarget(rightMotor, degreeToTurn, TURNINGSPEED);
        while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)&& getTouchValue(leftBumper)!=1 && getTouchValue(rightBumper)!=1) {
            setMotorSync(leftMotor, rightMotor, -100, TURNINGSPEED);
            currentDistance = getUSDistance(sonarSensor);
            if (currentDistance<previousDistance) {
                previousDistance = currentDistance; // it means it is turning toward to target;
                approachingTarget = true;
            } else if (approachingTarget && currentDistance > previousDistance && previousDistance < targetDistance) {
                targetDistance = previousDistance;
                return;
            }
        }
    }
}


/**
 * the robot scan first 45 degree to its left
 * then 90 degree to its right
 * at last 45 degree to its left
 * in any of these three steps, if it updated the target distance, it interupt turning.
 */
void scan() {
    approachingTarget = false;
    int scanDegree = 45;
    if(getTouchValue(leftBumper)==1 || getTouchValue(rightBumper)==1){
        return;
    } else {
        turn(-scanDegree, TURNINGSPEED);
        if (approachingTarget) {return;}
        turn(scanDegree*2,TURNINGSPEED);
        if (approachingTarget) {return;}
        turn(-scanDegree, TURNINGSPEED);
    }

}

/**
 * It is a helper function
 * bool leftMotorOrRightMotor indicates which wheel you want to turn
 * moterEncoder is the encoder you want to turn
 */
void turnOneMotor(bool leftMotorOrRightMotor, int motorEncoder)
{ // leftMotorOrRightMotor:
    // true, turn RIGHT motor,
    // false, turn LEFT motor.
    // motorEncoder, is the encoder you want the wheel to turn, positive means forward, negative means backward
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);

    if(leftMotorOrRightMotor) { // RightMotor move while LeftMotor stop
        if (motorEncoder > 0) { // move forward
            setMotorTarget(rightMotor, motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
                setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
            }
        } else if (motorEncoder<0) { // move backward
            setMotorTarget(rightMotor, -motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(rightMotor)!= -1*getMotorTarget(rightMotor)) {
                setMotorSync(leftMotor, rightMotor, -50, -TURNINGSPEED);
            }
        }
    } else {	// else false, LeftMotor move while RightMotor stop
        if (motorEncoder > 0) {
            setMotorTarget(leftMotor, motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
                setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
            }
        } else if (motorEncoder < 0) {
            setMotorTarget(leftMotor, -motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(leftMotor)!= -1*getMotorTarget(leftMotor)){
                setMotorSync(leftMotor, rightMotor, 50, -TURNINGSPEED);
            }
        }
    }
}

/**the robot move with one wheel, meet the boundary and move back
 * it returns the encoder in the turning process, so later it can use
 * the differences from right and left encoder to adjust its position.
 */
int turnOneMotorUntilMeetBoundary(bool leftOrRightMotor) {
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);

    int saved_leftBoundaryDegree = 0;
    int saved_rightBoundaryDegree = 0;

    if(leftOrRightMotor) {
        // turn RightMotor
        setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
        while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
            setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
        }

        saved_leftBoundaryDegree = getMotorEncoder(rightMotor);
        turnOneMotor(RIGHT, -1*saved_leftBoundaryDegree);
        return saved_leftBoundaryDegree;

    } else {
        setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
        while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
            setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
        }

        saved_rightBoundaryDegree = getMotorEncoder(leftMotor);
        turnOneMotor(LEFT, -1*saved_rightBoundaryDegree);
        return saved_rightBoundaryDegree;
    }
}

/**it stops on a black tile, tests the black tile's boundary and adjust its postion 
 *based on the difference of the encoder of wheels
 */
void testBoundary() {
    leftBoundaryDegree = turnOneMotorUntilMeetBoundary(RIGHT);
    rightBoundaryDegree = turnOneMotorUntilMeetBoundary(LEFT);
    differences = fabs(rightBoundaryDegree - leftBoundaryDegree);
    if(leftBoundaryDegree>rightBoundaryDegree) {
        turnOneMotor(RIGHT, differences/4);
        // turn(-differences/20);
    } else {
        turnOneMotor(LEFT, differences/4);
        //turn(differences/20);
    }

}

/**keep moving with speed until it encountered a black tile*/
void moveForwardWithSpeed(int movingSpeed) {
    TLegoColors previousColor = getColorName(colorSensor); // it should be black at start
    TLegoColors currentColor = getColorName(colorSensor);	// it should be black at start
    int count = 0;
    while(count<1 && getTouchValue(leftBumper)==0 && getTouchValue(rightBumper)==0){
        motor[leftMotor] = movingSpeed;
        motor[rightMotor] = movingSpeed;
        //setMotorSync(leftMotor, rightMotor, 0, movingSpeed);
        currentColor = getColorName(colorSensor);						// now robot enter the white tile.
        if (currentColor == colorWhite) {
            previousColor = colorWhite;
        } else if(currentColor == colorBlack && previousColor == colorWhite) {
            count++;
            previousColor = colorBlack;
            totalBlackTile++;
            playSound(soundUpwardTones);
        }
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    sleep(500);
}


void moveToLine(){
    moveForwardWithSpeed(MOVINGSPEED);
    turnOneMotor(RIGHT, 330);
}

void moveWithSpeedAndTime(int movingSpeed, int movingTime, int withRatio)
{
	setMotorSyncTime(leftMotor, rightMotor, withRatio, movingTime*1000, movingSpeed);
	wait1Msec(movingTime*1000);
}

task main()
{
    //stage 1
    moveToLine();
    while(totalBlackTile<15) {
        if (differences<20 && totalBlackTile<14) {
            moveForwardWithSpeed(MOVINGSPEED);
            moveForwardWithSpeed(MOVINGSPEED);
            testBoundary();
        } else  {
            moveForwardWithSpeed(MOVINGSPEED);
            testBoundary();
        }
    }

    // End of Stage 1

    // Start of stage 2:
    moveWithSpeedAndTime(-1*MOVINGSPEED, 1, 0);

    turnOneMotor(LEFT, 345);
    moveWithSpeedAndTime(MOVINGSPEED, 4, 0);


    while (getTouchValue(leftBumper)==0&&getTouchValue(rightBumper)==0){
        moveForwardWithSpeed(MOVINGSPEED);
        scan();
        if (targetDistance < 100) {
            TURNINGSPEED = 7;
        }
    }

    // After it making contacts with targets
    moveWithSpeedAndTime(-1*MOVINGSPEED, 2, 0); // moving back for 2 seconds
    moveWithSpeedAndTime(3*MOVINGSPEED, 2, 0); // then full speed and push 2 seconds
    moveWithSpeedAndTime(-1*MOVINGSPEED, 1, 0); // moving back for 1 second
    moveWithSpeedAndTime(MOVINGSPEED, 2, 100); //turning for 2 seconds

    playSound(soundUpwardTones);
    wait1Msec(1000);
}
